<h2 align= center> RESTfulAPI 架构设计 </h2>

<h5 align=right> 极客点儿 </h5>
<p align=right> 2020-08-12 </p>

### 一、深入理解 RESTful 架构

`RESTful` 架构是目前最流行的一种互联网软件架构。它结构清晰、符合标准、易于理解、扩展方便，所以正得到越来越多网站的采用。

但是，要彻底理解清楚 `RESTful` 架构，并不是一件容易的事情。下面，我就结合我自己的开发经验和理解，试图讲清楚到底什么是 `RESTful` 架构。

#### 1. 起源

`REST` 这个词，是 `Roy Thomas Fielding` 在他 `2000` 年的博士论文中提出的。

`Fielding` 是一个非常重要的人，他是 `HTTP` 协议（`1.0` 版和 `1.1` 版）的主要设计者、`Apache` 服务器软件的作者之一、`Apache` 基金会的第一任主席。所以，他的这篇论文一经发表，就引起了关注，并且立即对互联网开发产生了深远的影响。

#### 2. 名称

`Fielding` 将他对互联网软件的架构原则，定名为 `REST`，即 `Representational State Transfer` 的缩写。翻译过来是**“表现层状态转化”**。

如果一个架构符合 `REST` 原则，就称它为 `RESTful` 架构。

要理解 `RESTful` 架构，最好的方法就是去理解 `Representational State Transfer` 这个词组到底是什么意思，它的每一个词代表了什么涵义。如果你把这个名称搞懂了，也就不难体会 `REST` 是一种什么样的设计。

#### 3. 资源 `(Resources)`

`REST` 的名称**“表现层状态转化”**中，省略了主语。表现层其实指的是**“资源”**的表现层。

所谓**“资源”**，就是网络上的一个实体，或者说是网络上的一个具体信息。它可以是一段文本、一张图片、一首歌曲、一种服务，总之就是一个具体的实在。你可以用一个 `URI` 指向它，每种资源对应一个特定的 `URI`（统一资源定位符）。要获取这个资源，访问它的 `URI ` 就可以，因此 `URI` 就成了每一个资源的地址或独一无二的识别符，最典型的 `URI` 即 `URL`，`URL` 是 `URI` 的一个子集。

#### 4. 表现层 `(Representation)`

资源是一种信息实体，它可以有多种外在表现形式。我们把资源具体呈现出来的形式，叫做它的**“表现层”**。

比如，文本可以用 `TXT` 格式表现，也可以用 `HTML` 格式、`XML` 格式、`JSON` 格式表现，甚至可以采用二进制格式，图片可以用 `JPG`、 `PNG` 格式表现。

`URL` 只代表资源的实体，不代表它的形式。严格地说，有些网址最后的 `.html` 后缀名是不必要的，因为这个后缀名表示格式，属于"表现层"范畴，而 `URL` 应该只代表资源的位置。它的具体表现形式，应该在 `HTTP` 请求的头信息中用 `Accept` 和 `Content-Type` 字段指定，这两个字段才是对表现层的描述。

#### 5. 状态转化 `(State Transfer)`

访问一个网站，就代表了客户端和服务器的一个互动过程。在这个过程中，势必涉及到数据和状态的变化。

互联网通信协议 `HTTP` 协议，是一个无状态协议。这意味着，所有的状态都保存在服务器端。因此，如果客户端想要操作服务器，必须通过某种手段，让服务器端发生**“状态转化”**。而这种转化是建立在表现层之上的，所以就是**“表现层状态转化”**。

客户端用到的手段，只能是 `HTTP` 协议。具体来说，就是 `HTTP` 协议里面，四个表示操作方式的动词：`GET`、`POST`、`PUT`、`DELETE`。

它们分别对应四种基本操作：`GET` 用来获取资源，`POST` 用来新建资源，`PUT` 用来更新资源，`DELETE` 用来删除资源。

### 二、RESTful API 架构设计

现在已经知道何为 `RESTful` 了，接下来将介绍 `RESTful API` 的设计细节，探讨如何设计一套合理、好用的 `API`。

#### 1. 协议

`API` 与客户端的通信协议，使用 `HTTP` 或 `HTTPS` 协议，推荐使用 `HTTPS`。

#### 2. 域名

应将 `API` 部署在专用域名之下。

	https://api.example.com
	
如果确定 `API` 很简单，不会有进一步扩展，可以考虑放在主域名下。

	https://example.org/api/
	
#### 3. 版本

可以将 `API` 的版本号放入 `URL`。

	https://api.example.com/v1/
	
也可以将版本号放在 `HTTP` 头信息中。

	https://api.example.com -H "Authorization: version=v1.0"

#### 4. 路径

路径又称终点，表示 `API` 的具体网址。

在 `RESTful` 架构中，每个网址代表一种资源，所以网址中不能有动词，只能有名词，而且所用的名词往往与数据库的表格名对应。一般来说，数据库中的表都是同种记录的集合，所以 `API` 中的名词也应该使用复数。

#### 5. 操作

对于资源的具体操作类型，由 `HTTP` 动词表示，常用的 `HTTP` 动词有下面四个。

- `GET`：从服务器取出资源（一项或多项）。

- `POST`：在服务器新建一个资源。

- `PUT`：在服务器更新资源（客户端提供改变后的完整资源）。

- `DELETE`：从服务器删除资源。

还有三个不常用的 `HTTP` 动词。

- `HEAD`：获取资源的元数据。

- `PATCH`：在服务器更新资源（客户端提供改变的属性）。

- `OPTIONS`：获取信息，关于资源的哪些属性是客户端可以改变的。

#### 6. 状态码

服务器向用户返回的状态码和提示信息，其中最常用的如下。

| 状态码 | 提示信息 | 状态含义 |
|:---:|---|---|
| 200 | Success | 用户请求的服务器数据成功返回 |
| 201 | Created | 用户新建或修改数据成功 |
| 204 | No Content | 用户删除数据成功 |
| 400 | Bad Request | 用户发出的请求有错误，服务器没有进行新建或修改数据的操作 |
| 401 | Unauthorized | 用户认证失败，如：token、用户名、密码等错误|
| 403 | Forbidden | 用户认证成功，但没有权限，如：普通用户登录系统没有修改的权限 |
| 404 | Not Found | 用户发出的请求针对的是不存在的资源，服务器没有进行操作 |
| 500 | Internal Server Error | 服务器内部发生错误 |

完整的状态码请在[https://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html](https://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html)中查看。

#### 7. 返回值

在客户端请求服务器的时候，任何情况下都应该有返回值，至少也有状态码和消息。服务器返回的数据要求使用 `JSON` 格式，避免使用 `XML` 和其他格式。
	
	{
		"status": 200,
		"message": "获取资源成功"
	}

#### 8. 过滤数据

如果记录数量很多，服务器不可能都将它们返回给用户。`API` 应该提供参数，过滤返回结果。一般有几类可供选择。

- 分页：应该至少提供四个参数，数据总条数、总页数、每页条数、当前页码。

- 排序：应该至少提供两个参数，其中一个指定排序方式（正序、逆序）。另一个指定哪个或哪几个字段参与排序。

- 搜索：搜索可分为模糊搜索、精确搜索、字段搜索和全局搜索。将这些组合排列可以确定四种搜索模式，即全局模糊搜索、字段模糊搜索、全局精确搜索、字段精确搜索。

#### 9. 错误处理

如果状态码是 `4xx` 或 `5xx`，就应该向用户返回出错信息，有两种方式可以参考。

第一种，在返回的信息中将 `error` 作为键名，出错信息作为键值即可。
	
	{
		"status": 400,
		"message": "请求参数错误",
		"error": "Bad Request"
	}
	
第二种，省略返回值中的 `error` 字段，直接通过状态码进行判断，二者选择其中一个即可。

	{
		"status": 400,
		"message": "请求参数错误",
	}
	
如果追求格式统一，就选择第二种方式。

#### 10. 认证机制

认证机制基本上是通用的，在开发中常用的认证机制如下。

- `Session Auth`：是通过用户名、密码来登录，是单体结构的系统最常用的认证机制， `session` 存储在服务端。

- `Cookie Auth`：和 `session` 类似，一般 `session` 和 `cookie` 协同工作，`cookie` 存储在客户端。

- `Basic Auth`：是配合 `RESTful API` 使用的最简单的认证方式，只需在调用 `API` 时提供用户名密码即可，但是这样会有很大的安全隐患。

- `Token Auth`：是经过 `Basic Auth` 演化过来的，不将用户名和密码发送给服务器做用户认证，而是向服务器发送一个事先在服务器端生成的 `Token` 来做认证，服务器端要具备一套完整的 `Token` 创建和管理机制，安全性很高！

- `OAuth 2.0`：是一个开放的授权标准，数据的所有者告诉系统，同意授权第三方应用进入系统内获取这些数据。系统从而产生一个短期的进入令牌 `token`，用来代替密码，供第三方应用使用。`OAuth 2.0` 的严谨性和安全性最高！常用于 `RESTful` 架构中，依然成为了微服务的标配。

- `OIDC`：`OIDC` 是 `(OpenID Connect)` 的简称，`OIDC =  OpenID + OAuth 2.0`。它是在 `OAuth 2.0` 上构建了一个身份层，是一个基于 `OAuth 2.0` 协议的身份认证标准协议。`OAuth 2.0` 是一个授权协议，它无法提供完善的身份认证功能，`OIDC` 使用 `OAuth2.0` 的授权服务器来为第三方客户端提供用户的身份认证，并把对应的身份认证信息传递给客户端。

`OpenID` 和 `OAuth 2.0` 很像。但本质上来说它们是截然不同的两个东西。

- `OpenID`: 只用于身份认证，允许你以 同一个账户在多个网站登陆。它仅仅是为你的合法身份背书。

- `OAuth 2.0`: 用于授权，允许被授权方访问授权方的用户数据。

具体如何选择是根据具体业务，如果是面向 `C` 端，具有高并发、大流量、安全性要求很高的场景推荐使用`OAuth 2.0`。如果是是面向 `B` 端或者是企业内部的系统，方便维护、开发推荐使用 `Token Auth`。
